"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const linq_1 = require("@azure-tools/linq");
const aio = require("@azure-tools/async-io");
const path_1 = require("path");
function getAllPropertyNames(obj) {
    const props = new Array();
    do {
        Object.getOwnPropertyNames(obj).forEach(function (prop) {
            if (props.indexOf(prop) === -1) {
                props.push(prop);
            }
        });
        /* eslint-disable */
    } while (obj = Object.getPrototypeOf(obj));
    return props;
}
function fail(text) {
    throw new Error(text);
}
exports.fail = fail;
function applyOverrides(content, overrides) {
    for (const { key: from, value: to } of linq_1.items(overrides)) {
        content = content.replace(new RegExp(from, 'g'), to);
    }
    return content;
}
exports.applyOverrides = applyOverrides;
async function copyResources(sourceFolder, fileWriter, overrides = {}, contentManipulator = async (i) => { return i; }) {
    const done = new Array();
    try {
        const files = await aio.readdir(sourceFolder);
        for (const file of linq_1.values(files)) {
            const fullPath = path_1.join(sourceFolder, file);
            if (await aio.isDirectory(fullPath)) {
                done.push(copyResources(fullPath, async (f, c) => fileWriter(`${file}/${f}`, c), overrides, contentManipulator));
                continue;
            }
            if (await aio.isFile(fullPath)) {
                done.push(aio.readFile(fullPath).then(contentManipulator).then(async (content) => fileWriter(file, applyOverrides(content, overrides))));
            }
        }
    }
    catch (_a) {
        // ignore failures
    }
    await Promise.all(done);
}
exports.copyResources = copyResources;
async function copyBinaryResources(sourceFolder, fileWriter) {
    const done = new Array();
    try {
        const files = await aio.readdir(sourceFolder);
        for (const file of linq_1.values(files)) {
            const fullPath = path_1.join(sourceFolder, file);
            if (await aio.isDirectory(fullPath)) {
                done.push(copyBinaryResources(fullPath, async (f, c) => fileWriter(`${file}/${f}`, c)));
                continue;
            }
            if (await aio.isFile(fullPath)) {
                done.push(aio.readBinaryFile(fullPath).then(async (content) => fileWriter(file, content)));
            }
        }
    }
    catch (_a) {
        // ignore failures
    }
    await Promise.all(done);
}
exports.copyBinaryResources = copyBinaryResources;
function quartet() {
    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
}
function guid() {
    return (quartet() + quartet() + '-' + quartet() + '-4' + quartet().substr(0, 3) + '-' + quartet() + '-' + quartet() + quartet() + quartet()).toLowerCase();
}
exports.guid = guid;
//# sourceMappingURL=utility.js.map